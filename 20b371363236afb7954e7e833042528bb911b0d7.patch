From 20b371363236afb7954e7e833042528bb911b0d7 Mon Sep 17 00:00:00 2001
From: Michael Tao <michael.tao@nyu.edu>
Date: Tue, 14 May 2024 20:10:55 -0400
Subject: [PATCH] adding a tool for checking if all tuples mapped are valid

---
 src/wmtk/Mesh.hpp                            |  2 +
 src/wmtk/multimesh/MultiMeshManager.cpp      |  9 ++-
 src/wmtk/multimesh/MultiMeshManager.hpp      |  6 ++
 src/wmtk/multimesh/utils/CMakeLists.txt      |  4 +
 src/wmtk/multimesh/utils/check_map_valid.cpp | 80 ++++++++++++++++++++
 src/wmtk/multimesh/utils/check_map_valid.hpp | 14 ++++
 tests/CMakeLists.txt                         |  1 +
 tests/multimesh/test_multi_mesh.cpp          |  6 +-
 8 files changed, 118 insertions(+), 4 deletions(-)
 create mode 100644 src/wmtk/multimesh/utils/check_map_valid.cpp
 create mode 100644 src/wmtk/multimesh/utils/check_map_valid.hpp

diff --git a/src/wmtk/Mesh.hpp b/src/wmtk/Mesh.hpp
index af813fb2f6..0e022867ee 100644
--- a/src/wmtk/Mesh.hpp
+++ b/src/wmtk/Mesh.hpp
@@ -106,6 +106,8 @@ class Mesh : public std::enable_shared_from_this<Mesh>, public wmtk::utils::Merk
     friend class multimesh::MultiMeshSimplexVisitorExecutor;
     template <typename NodeFunctor>
     friend class multimesh::MultiMeshVisitor;
+    friend bool multimesh::utils::check_child_maps_valid(const Mesh& m);
+    friend bool multimesh::utils::check_parent_map_valid(const Mesh& m);
     template <typename Visitor>
     friend class multimesh::MultiMeshVisitorExecutor;
     friend class multimesh::attribute::AttributeScopeHandle;
diff --git a/src/wmtk/multimesh/MultiMeshManager.hpp b/src/wmtk/multimesh/MultiMeshManager.hpp
index 971cbf3604..51da8d6089 100644
--- a/src/wmtk/multimesh/MultiMeshManager.hpp
+++ b/src/wmtk/multimesh/MultiMeshManager.hpp
@@ -9,6 +9,9 @@
 #include <wmtk/operations/utils/UpdateVertexMultiMeshMapHash.hpp>
 #include <wmtk/utils/MerkleTreeInteriorNode.hpp>
 
+// debug function that reads into this structure
+#include "utils/check_map_valid.hpp"
+
 
 namespace wmtk {
 
@@ -69,6 +72,9 @@ class MultiMeshManager : public wmtk::utils::MerkleTreeInteriorNode
     friend class multimesh::MultiMeshVisitorExecutor;
     friend class wmtk::HDF5Reader;
 
+    friend bool utils::check_child_maps_valid(const Mesh& m);
+    friend bool utils::check_parent_map_valid(const Mesh& m);
+
 
     // @param the max dimension of the mesh we will get passed
     MultiMeshManager(int64_t dimension);
diff --git a/src/wmtk/multimesh/utils/CMakeLists.txt b/src/wmtk/multimesh/utils/CMakeLists.txt
index f33259ace3..71087367bd 100644
--- a/src/wmtk/multimesh/utils/CMakeLists.txt
+++ b/src/wmtk/multimesh/utils/CMakeLists.txt
@@ -16,5 +16,9 @@ set(SRC_FILES
     create_tag.cpp
     extract_child_mesh_from_tag.hpp
     extract_child_mesh_from_tag.cpp
+
+
+    check_map_valid.cpp
+    check_map_valid.hpp
     )
 target_sources(wildmeshing_toolkit PRIVATE ${SRC_FILES})
diff --git a/src/wmtk/multimesh/utils/check_map_valid.cpp b/src/wmtk/multimesh/utils/check_map_valid.cpp
new file mode 100644
index 0000000000..047c36107e
--- /dev/null
+++ b/src/wmtk/multimesh/utils/check_map_valid.cpp
@@ -0,0 +1,80 @@
+
+#include <wmtk/Mesh.hpp>
+#include <wmtk/multimesh/utils/tuple_map_attribute_io.hpp>
+#include <wmtk/simplex/top_dimension_cofaces.hpp>
+#include <wmtk/utils/Logger.hpp>
+#include <wmtk/utils/TupleInspector.hpp>
+namespace wmtk::multimesh::utils {
+bool check_child_maps_valid(const Mesh& m)
+{
+    bool ok = true;
+    for (const auto& [cptr, attr] : m.m_multi_mesh_manager.m_children) {
+        const auto& child = *cptr;
+        auto map_accessor = m.create_const_accessor(attr);
+
+        for (int64_t j = 0; j < child.top_cell_dimension(); ++j) {
+            wmtk::PrimitiveType prim_type = wmtk::PrimitiveType(j);
+
+            for (const auto& pt : m.get_all(prim_type)) {
+                wmtk::simplex::Simplex s(m, prim_type, pt);
+
+                auto tups = simplex::top_dimension_cofaces_tuples(m, s);
+
+                for (const auto& source_tuple : tups) {
+                    const auto [source_mesh_base_tuple, target_mesh_base_tuple] =
+                        multimesh::utils::read_tuple_map_attribute(map_accessor, source_tuple);
+                    if (!child.is_valid_slow(target_mesh_base_tuple)) {
+                        wmtk::logger().error(
+                            "Map from parent {} to child {} on tuple {} (dim {}) fails on  {} -> "
+                            "{}",
+                            fmt::join(m.absolute_multi_mesh_id(), ","),
+                            fmt::join(child.absolute_multi_mesh_id(), ","),
+                            j,
+                            wmtk::utils::TupleInspector::as_string(pt),
+                            wmtk::utils::TupleInspector::as_string(source_mesh_base_tuple),
+                            wmtk::utils::TupleInspector::as_string(target_mesh_base_tuple)
+
+                        );
+                        ok = false;
+                    }
+                }
+            }
+        }
+    }
+    return ok;
+}
+
+bool check_parent_map_valid(const Mesh& m)
+{
+    bool ok = true;
+    const auto& parent_ptr = m.m_multi_mesh_manager.m_parent;
+    if (parent_ptr == nullptr) {
+        return true;
+    }
+    const auto& attr = m.m_multi_mesh_manager.map_to_parent_handle;
+    const auto& parent = *parent_ptr;
+    auto map_accessor = m.create_const_accessor(attr);
+
+    wmtk::PrimitiveType prim_type = m.top_simplex_type();
+
+    for (const auto& source_tuple : m.get_all(prim_type)) {
+        const auto [source_mesh_base_tuple, target_mesh_base_tuple] =
+            multimesh::utils::read_tuple_map_attribute(map_accessor, source_tuple);
+        if (!parent.is_valid_slow(target_mesh_base_tuple)) {
+            wmtk::logger().error(
+                "Map from child {} to parent {} on tuple {} (dim {}) fails on  {} -> "
+                "{}",
+                fmt::join(m.absolute_multi_mesh_id(), ","),
+                fmt::join(parent.absolute_multi_mesh_id(), ","),
+                m.top_cell_dimension(),
+                wmtk::utils::TupleInspector::as_string(source_tuple),
+                wmtk::utils::TupleInspector::as_string(source_mesh_base_tuple),
+                wmtk::utils::TupleInspector::as_string(target_mesh_base_tuple)
+
+            );
+            ok = false;
+        }
+    }
+    return ok;
+}
+} // namespace wmtk::multimesh::utils
diff --git a/src/wmtk/multimesh/utils/check_map_valid.hpp b/src/wmtk/multimesh/utils/check_map_valid.hpp
new file mode 100644
index 0000000000..ec46a4dd52
--- /dev/null
+++ b/src/wmtk/multimesh/utils/check_map_valid.hpp
@@ -0,0 +1,14 @@
+#pragma once
+
+namespace wmtk {
+class Mesh;
+namespace multimesh {
+class MultiMeshManager;
+}
+} // namespace wmtk
+
+namespace wmtk::multimesh::utils {
+bool check_child_maps_valid(const Mesh& m);
+bool check_parent_map_valid(const Mesh& m);
+
+} // namespace wmtk::multimesh::utils
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index 255c68b804..d3a40599ea 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -29,6 +29,7 @@ tools/DEBUG_MultiMeshManager.hpp
 tools/DEBUG_MultiMeshManager.cpp
 tools/DEBUG_Tuple.hpp
 tools/DEBUG_Tuple.cpp
+
 )
 add_library(wmtk_test_tools ${TEST_TOOLS})
 target_include_directories(wmtk_test_tools PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
diff --git a/tests/multimesh/test_multi_mesh.cpp b/tests/multimesh/test_multi_mesh.cpp
index 43d3c054ec..e226803401 100644
--- a/tests/multimesh/test_multi_mesh.cpp
+++ b/tests/multimesh/test_multi_mesh.cpp
@@ -4,6 +4,7 @@
 #include <wmtk/multimesh/same_simplex_dimension_bijection.hpp>
 #include <wmtk/multimesh/same_simplex_dimension_surjection.hpp>
 #include <wmtk/multimesh/utils/tuple_map_attribute_io.hpp>
+#include <wmtk/multimesh/utils/check_map_valid.hpp>
 #include <wmtk/operations/EdgeCollapse.hpp>
 #include <wmtk/operations/EdgeSplit.hpp>
 #include "../tools/DEBUG_EdgeMesh.hpp"
@@ -71,6 +72,9 @@ TEST_CASE("test_register_child_mesh_bijection", "[multimesh][2D]")
     REQUIRE(child0_map == child1_map);
 
 
+    REQUIRE(wmtk::multimesh::utils::check_child_maps_valid(parent));
+    REQUIRE(wmtk::multimesh::utils::check_child_maps_valid(child0));
+    REQUIRE(wmtk::multimesh::utils::check_child_maps_valid(child1));
     // some debug mode only checks
 #if !defined(NDEBUG)
     // chekc that it fails when the # simplices is wrong
@@ -1337,4 +1341,4 @@ TEST_CASE("test_deregister_child_mesh", "[multimesh]")
         CHECK(c1_mul_manager.is_root());
         CHECK_FALSE(c0_mul_manager.is_root());
     }
-}
\ No newline at end of file
+}
