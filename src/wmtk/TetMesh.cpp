#include "TetMesh.hpp"

#include <wmtk/autogen/autogenerated_3d_tables.hpp>

#include <wmtk/utils/tetmesh_topology_initialization.h>
#include <wmtk/SimplicialComplex.hpp>
#include <wmtk/utils/Logger.hpp>

namespace wmtk {

using namespace autogen;

TetMesh::TetMesh()
    : Mesh(3)
    , m_vt_handle(register_attribute<long>("m_vt", PrimitiveType::Vertex, 1))
    , m_et_handle(register_attribute<long>("m_et", PrimitiveType::Edge, 1))
    , m_ft_handle(register_attribute<long>("m_ft", PrimitiveType::Face, 1))
    , m_tv_handle(register_attribute<long>("m_tv", PrimitiveType::Tetrahedron, 4))
    , m_te_handle(register_attribute<long>("m_te", PrimitiveType::Tetrahedron, 6))
    , m_tf_handle(register_attribute<long>("m_tf", PrimitiveType::Tetrahedron, 4))
    , m_tt_handle(register_attribute<long>("m_tt", PrimitiveType::Tetrahedron, 4))
{}


void TetMesh::initialize(
    Eigen::Ref<const RowVectors4l> TV,
    Eigen::Ref<const RowVectors6l> TE,
    Eigen::Ref<const RowVectors4l> TF,
    Eigen::Ref<const RowVectors4l> TT,
    Eigen::Ref<const VectorXl> VT,
    Eigen::Ref<const VectorXl> ET,
    Eigen::Ref<const VectorXl> FT)

{
    // reserve memory for attributes

    std::vector<long> cap{
        static_cast<long>(VT.rows()),
        static_cast<long>(ET.rows()),
        static_cast<long>(FT.rows()),
        static_cast<long>(TT.rows())};
    set_capacities(cap);

    // get Accessors for topology
    Accessor<long> vt_accessor = create_accessor<long>(m_vt_handle);
    Accessor<long> et_accessor = create_accessor<long>(m_et_handle);
    Accessor<long> ft_accessor = create_accessor<long>(m_ft_handle);

    Accessor<long> tv_accessor = create_accessor<long>(m_tv_handle);
    Accessor<long> te_accessor = create_accessor<long>(m_te_handle);
    Accessor<long> tf_accessor = create_accessor<long>(m_tf_handle);
    Accessor<long> tt_accessor = create_accessor<long>(m_tt_handle);

    Accessor<char> v_flag_accessor = get_flag_accessor(PrimitiveType::Vertex);
    Accessor<char> e_flag_accessor = get_flag_accessor(PrimitiveType::Edge);
    Accessor<char> f_flag_accessor = get_flag_accessor(PrimitiveType::Face);
    Accessor<char> t_flag_accessor = get_flag_accessor(PrimitiveType::Tetrahedron);

    // iterate over the matrices and fill attributes
    for (long i = 0; i < capacity(PrimitiveType::Tetrahedron); ++i) {
        tv_accessor.index_access().vector_attribute(i) = TV.row(i).transpose();
        te_accessor.index_access().vector_attribute(i) = TE.row(i).transpose();
        tf_accessor.index_access().vector_attribute(i) = TF.row(i).transpose();
        tt_accessor.index_access().vector_attribute(i) = TT.row(i).transpose();
        t_flag_accessor.index_access().scalar_attribute(i) |= 0x1;
    }
    // m_vt
    for (long i = 0; i < capacity(PrimitiveType::Vertex); ++i) {
        vt_accessor.index_access().scalar_attribute(i) = VT(i);
        v_flag_accessor.index_access().scalar_attribute(i) |= 0x1;
    }
    // m_et
    for (long i = 0; i < capacity(PrimitiveType::Edge); ++i) {
        et_accessor.index_access().scalar_attribute(i) = ET(i);
        e_flag_accessor.index_access().scalar_attribute(i) |= 0x1;
    }
    // m_ft
    for (long i = 0; i < capacity(PrimitiveType::Face); ++i) {
        ft_accessor.index_access().scalar_attribute(i) = FT(i);
        f_flag_accessor.index_access().scalar_attribute(i) |= 0x1;
    }
}


void TetMesh::initialize(Eigen::Ref<const RowVectors4l> T)
{
    auto [TE, TF, TT, VT, ET, FT] = tetmesh_topology_initialization(T);
    initialize(T, TE, TF, TT, VT, ET, FT);
}

long TetMesh::_debug_id(const Tuple& tuple, PrimitiveType type) const
{
    // do not remove this warning!
    wmtk::logger().warn("This function must only be used for debugging!!");
    return id(tuple, type);
}

Tuple TetMesh::vertex_tuple_from_id(long id) const
{
    ConstAccessor<long> vt_accessor = create_accessor<long>(m_vt_handle);
    long t = vt_accessor.index_access().scalar_attribute(id);
    ConstAccessor<long> tv_accessor = create_accessor<long>(m_tv_handle);
    auto tv = tv_accessor.index_access().vector_attribute(t);
    long lvid = -1, leid = -1, lfid = -1;

    for (long i = 0; i < 4; ++i) {
        if (tv(i) == id) {
            lvid = i;
            break;
        }
    }

    assert(auto_3d_table_complete_vertex[lvid][0] == lvid);

    leid = auto_3d_table_complete_vertex[lvid][1];
    lfid = auto_3d_table_complete_vertex[lvid][2];

    if (lvid < 0 || leid < 0 || lfid < 0) throw std::runtime_error("vertex_tuple_from_id failed");

    ConstAccessor<long> hash_accessor = get_const_cell_hash_accessor();

    Tuple v_tuple = Tuple(lvid, leid, lfid, t, get_cell_hash(t, hash_accessor));
    assert(is_ccw(v_tuple));
    assert(is_valid(v_tuple, hash_accessor));
    return v_tuple;
}

Tuple TetMesh::edge_tuple_from_id(long id) const
{
    ConstAccessor<long> et_accessor = create_accessor<long>(m_et_handle);
    long t = et_accessor.index_access().scalar_attribute(id);
    ConstAccessor<long> te_accessor = create_accessor<long>(m_te_handle);
    auto te = te_accessor.index_access().vector_attribute(t);

    long lvid = -1, leid = -1, lfid = -1;

    for (long i = 0; i < 6; ++i) {
        if (te(i) == id) {
            leid = i;
            break;
        }
    }

    assert(auto_3d_table_complete_edge[leid][1] == leid);

    lvid = auto_3d_table_complete_edge[leid][0];
    lfid = auto_3d_table_complete_edge[leid][2];

    if (lvid < 0 || leid < 0 || lfid < 0) throw std::runtime_error("edge_tuple_from_id failed");

    ConstAccessor<long> hash_accessor = get_const_cell_hash_accessor();

    Tuple e_tuple = Tuple(lvid, leid, lfid, t, get_cell_hash(t, hash_accessor));
    assert(is_ccw(e_tuple));
    assert(is_valid(e_tuple, hash_accessor));
    return e_tuple;
}

Tuple TetMesh::face_tuple_from_id(long id) const
{
    ConstAccessor<long> ft_accessor = create_accessor<long>(m_ft_handle);
    long t = ft_accessor.index_access().scalar_attribute(id);
    ConstAccessor<long> tf_accessor = create_accessor<long>(m_tf_handle);
    auto tf = tf_accessor.index_access().vector_attribute(t);

    long lvid = -1, leid = -1, lfid = -1;

    for (long i = 0; i < 4; ++i) {
        if (tf(i) == id) {
            lfid = i;
            break;
        }
    }

    assert(auto_3d_table_complete_face[lfid][2] == lfid);

    lvid = auto_3d_table_complete_face[lfid][0];
    leid = auto_3d_table_complete_face[lfid][1];

    if (lvid < 0 || leid < 0 || lfid < 0) throw std::runtime_error("face_tuple_from_id failed");

    ConstAccessor<long> hash_accessor = get_const_cell_hash_accessor();

    Tuple f_tuple = Tuple(lvid, leid, lfid, t, get_cell_hash(t, hash_accessor));
    assert(is_ccw(f_tuple));
    assert(is_valid(f_tuple, hash_accessor));
    return f_tuple;
}

Tuple TetMesh::tet_tuple_from_id(long id) const
{
    long lvid = 0, leid = -1, lfid = -1;

    assert(auto_3d_table_complete_vertex[lvid][0] == lvid);

    leid = auto_3d_table_complete_vertex[lvid][1];
    lfid = auto_3d_table_complete_vertex[lvid][2];

    ConstAccessor<long> hash_accessor = get_const_cell_hash_accessor();

    Tuple t_tuple = Tuple(lvid, leid, lfid, id, get_cell_hash(id, hash_accessor));
    assert(is_ccw(t_tuple));
    assert(is_valid(t_tuple, hash_accessor));
    return t_tuple;
}

Tuple TetMesh::tuple_from_id(const PrimitiveType type, const long gid) const
{
    switch (type) {
    case PrimitiveType::Vertex: {
        return vertex_tuple_from_id(gid);
        break;
    }
    case PrimitiveType::Edge: {
        return edge_tuple_from_id(gid);
        break;
    }
    case PrimitiveType::Face: {
        return face_tuple_from_id(gid);
        break;
    }
    case PrimitiveType::Tetrahedron: {
        return tet_tuple_from_id(gid);
        break;
    }
    default: throw std::runtime_error("Invalid primitive type");
    }
}

Tuple TetMesh::split_edge(const Tuple& t, Accessor<long>& hash_accessor)
{
    throw "not implemented";
}

Tuple TetMesh::collapse_edge(const Tuple& t, Accessor<long>& hash_accessor)
{
    throw "not implemented";
}

long TetMesh::id(const Tuple& tuple, PrimitiveType type) const
{
    switch (type) {
    case PrimitiveType::Vertex: {
        ConstAccessor<long> tv_accessor = create_accessor<long>(m_tv_handle);
        auto tv = tv_accessor.vector_attribute(tuple);
        return tv(tuple.m_local_vid);
        break;
    }
    case PrimitiveType::Edge: {
        ConstAccessor<long> te_accessor = create_accessor<long>(m_te_handle);
        auto te = te_accessor.vector_attribute(tuple);
        return te(tuple.m_local_eid);
        break;
    }
    case PrimitiveType::Face: {
        ConstAccessor<long> tf_accessor = create_accessor<long>(m_tf_handle);
        auto tf = tf_accessor.vector_attribute(tuple);
        return tf(tuple.m_local_fid);
        break;
    }
    case PrimitiveType::Tetrahedron: {
        return tuple.m_global_cid;
        break;
    }
    default: throw std::runtime_error("Tuple id: Invalid primitive type");
    }
}

Tuple TetMesh::switch_tuple(const Tuple& tuple, PrimitiveType type) const
{
    assert(is_valid_slow(tuple));
    const long offset = tuple.m_local_vid * 6 * 4 + tuple.m_local_eid * 4 + tuple.m_local_fid;
    // bool ccw = is_ccw(tuple);
    switch (type) {
    case PrimitiveType::Vertex:
        return Tuple(
            auto_3d_table_vertex[offset][0],
            auto_3d_table_vertex[offset][1],
            auto_3d_table_vertex[offset][2],
            tuple.m_global_cid,
            tuple.m_hash);

    case PrimitiveType::Edge:
        return Tuple(
            auto_3d_table_edge[offset][0],
            auto_3d_table_edge[offset][1],
            auto_3d_table_edge[offset][2],
            tuple.m_global_cid,
            tuple.m_hash);
    case PrimitiveType::Face:
        return Tuple(
            auto_3d_table_face[offset][0],
            auto_3d_table_face[offset][1],
            auto_3d_table_face[offset][2],
            tuple.m_global_cid,
            tuple.m_hash);
    case PrimitiveType::Tetrahedron: {
        throw "Not implemented";
    }
    default: throw std::runtime_error("Tuple switch: Invalid primitive type"); break;
    }
}

bool TetMesh::is_ccw(const Tuple& tuple) const
{
    assert(is_valid_slow(tuple));
    const long offset = tuple.m_local_vid * 6 * 4 + tuple.m_local_eid * 4 + tuple.m_local_fid;
    return autogen::auto_3d_table_ccw[offset][0] == 1;
}

bool TetMesh::is_valid(const Tuple& tuple, ConstAccessor<long>& hash_accessor) const
{
    if (tuple.is_null()) return false;
    const long offset = tuple.m_local_vid * 6 * 4 + tuple.m_local_eid * 4 + tuple.m_local_fid;
    const bool is_connectivity_valid = tuple.m_local_vid >= 0 && tuple.m_local_eid >= 0 &&
                                       tuple.m_local_fid >= 0 && tuple.m_global_cid >= 0 &&
                                       auto_3d_table_ccw[offset][0] >= 0;

    if (!is_connectivity_valid) {
        return false;
    }

    return Mesh::is_hash_valid(tuple, hash_accessor);
}

bool TetMesh::is_boundary(const Tuple& tuple) const
{
    ConstAccessor<long> tt_accessor = create_accessor<long>(m_tt_handle);
    return tt_accessor.vector_attribute(tuple)(tuple.m_local_fid) < 0;
}

bool TetMesh::is_boundary_edge(const Tuple& vertex) const
{
    assert(false);
    throw "NotImplemented";
}
bool TetMesh::is_boundary_vertex(const Tuple& vertex) const
{
    // go through all faces and check if they are boundary
    const SimplicialComplex neigh = SimplicialComplex::open_star(*this, Simplex::vertex(vertex));
    for (const Simplex& s : neigh.get_faces()) {
        if (is_boundary(s.tuple())) {
            return true;
        }
    }

    return false;
}

bool TetMesh::is_connectivity_valid() const
{
    throw("Not implemented");
    return true;
}


} // namespace wmtk
