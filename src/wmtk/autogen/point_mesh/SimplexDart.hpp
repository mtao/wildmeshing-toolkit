
#pragma once
// DO NOT MODIFY, autogenerated from the /scripts directory
#include <Eigen/Core>
#include <array>
#include <cassert>
#include <wmtk/PrimitiveType.hpp>
#include <wmtk/Types.hpp>
#include <wmtk/dart/SimplexDart.hpp>

namespace wmtk::autogen::point_mesh {
namespace constants {
constexpr PrimitiveType primitive_type = wmtk::PrimitiveType::Vertex;
constexpr int8_t simplex_dimension = get_primitive_type_id(primitive_type);

extern const std::array<int8_t, 1> _indices;
} // namespace constants

inline int8_t product(int8_t a, int8_t b)
{
    assert(a == 0 && b == 0);
    return 0;
}
inline int8_t inverse(int8_t a)
{
    return 0;
}
inline int8_t permutation_index_from_primitive_switch(wmtk::PrimitiveType)
{
    return 0;
}
inline int8_t identity()
{
    return 0;
}
inline int8_t opposite()
{
    return 0;
}
inline int8_t simplex_index(int8_t permutation_index, wmtk::PrimitiveType type)
{
    return 0;
}
constexpr inline size_t size()
{
    return 1;
}

inline auto permutation_indices()
{
    return Vector<int8_t, 1>::ConstMapType(constants::_indices.data());
}
inline auto permutation_indices_dynamic()
{
    return VectorX<int8_t>::ConstMapType(constants::_indices.data(), size());
}

class SimplexDart : public wmtk::dart::SimplexDart
{
public:
    ~SimplexDart() override;
    int8_t product(int8_t a, int8_t b) const final;
    int8_t inverse(int8_t a) const final;
    // returns the action equivalent to switching by a particular primitive
    int8_t permutation_index_from_primitive_switch(wmtk::PrimitiveType pt) const final;
    int8_t identity() const final;
    int8_t opposite() const final;
    size_t size() const final;

    VectorX<int8_t>::ConstMapType permutation_indices() const final;
    int8_t simplex_index(int8_t permutation_index, wmtk::PrimitiveType type) const final;
    wmtk::PrimitiveType simplex_type() const final;
};
} // namespace wmtk::autogen::point_mesh
