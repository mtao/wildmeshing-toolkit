#include "from_local_vertex_permutation.hpp"
#include <algorithm>
#include <iterator>
#include <map>
#include <span>
#include <wmtk/autogen/edge_mesh/autogenerated_tables.hpp>
#include <wmtk/autogen/tet_mesh/autogenerated_tables.hpp>
#include <wmtk/autogen/tri_mesh/autogenerated_tables.hpp>
#include <wmtk/dart/SimplexDart.hpp>
namespace wmtk::dart::utils {
namespace {


template <size_t Rows, size_t Cols>
int8_t from_local_vertex_permutation_slow(
    Eigen::Ref<const VectorX<int8_t>> permutation,
    const int8_t p[Rows][Cols])
{
    using CMT = typename Vector<int8_t, Cols>::ConstMapType;
    for (size_t j = 0; j < Rows; ++j) {
        auto x = CMT(p[j]);
        if (x == permutation) {
            return j;
        }
    }
    return -1;
}

template <size_t Rows, size_t Cols>
std::array<std::pair<std::array<int8_t, Cols>, int8_t>, Rows> local_indexer(
    const int8_t p[Rows][Cols])
{
    std::array<std::pair<std::array<int8_t, Cols>, int8_t>, Rows> R;
    using CMT = typename Vector<int8_t, Cols>::ConstMapType;
    for (size_t j = 0; j < Rows; ++j) {
        auto x = CMT(p[j]);
        std::copy(x.begin(), x.end(), R[j].first.begin());
        R[j].second = j;
    }
    std::sort(R.begin(), R.end());
    return R;
}

template <size_t Rows, size_t Cols>
int8_t get_index(
    const std::array<std::pair<std::array<int8_t, Cols>, int8_t>, Rows>& LI,
    Eigen::Ref<const Vector<int8_t, Cols>> permutation)
{
    auto it = std::lower_bound(LI.begin(), LI.end(), permutation, [](const auto& a, const auto& b) {
        return std::lexicographical_compare(a.first.begin(), a.first.end(), b.begin(), b.end());
    });
    assert(std::equal(it->first.begin(), it->first.end(), permutation.begin(), permutation.end()));
    return it->second;
}

template <size_t Rows>
int8_t from_local_vertex_permutation(Eigen::Ref<const Vector<int8_t, Rows>> permutation);
template <>
int8_t from_local_vertex_permutation<2>(Eigen::Ref<const Vector<int8_t, 2>> permutation)
{
    const static auto LI = local_indexer<2>(autogen::edge_mesh::permutations);
    return get_index<2, 2>(LI, permutation);
}
template <>
int8_t from_local_vertex_permutation<3>(Eigen::Ref<const Vector<int8_t, 3>> permutation)
{
    const static auto LI = local_indexer<6>(autogen::tri_mesh::permutations);
    return get_index<6, 3>(LI, permutation);
}
template <>
int8_t from_local_vertex_permutation<4>(Eigen::Ref<const Vector<int8_t, 4>> permutation)
{
    const static auto LI = local_indexer<24>(autogen::tet_mesh::permutations);
    return get_index<24, 4>(LI, permutation);
}
} // namespace

int8_t from_local_vertex_permutation(Eigen::Ref<const VectorX<int8_t>> permutation)
{
    PrimitiveType pt = get_primitive_type_from_id(permutation.size() - 1);
    const static int8_t x = 1;
    switch (pt) {
    case PrimitiveType::Edge: return from_local_vertex_permutation<2>(permutation);
    case PrimitiveType::Triangle: return from_local_vertex_permutation<3>(permutation);
    case PrimitiveType::Tetrahedron: return from_local_vertex_permutation<4>(permutation);
    case PrimitiveType::Vertex: return 0;
    default: return -1;
    }
}
int8_t from_local_vertex_permutation(
    PrimitiveType pt,
    Eigen::Ref<const VectorX<int8_t>> permutation)
{
    assert(pt == get_primitive_type_from_id(permutation.size() - 1));
    return from_local_vertex_permutation(permutation);
}

int8_t from_vertex_permutation(Eigen::Ref<const VectorX<int64_t>> indices)
{
    PrimitiveType pt = get_primitive_type_from_id(indices.size() - 1);
    std::map<int64_t, int8_t> map;
    for (int8_t j = 0; j < indices.size(); ++j) {
        map[indices[j]] = j;
    }
    std::vector<int8_t> I(indices.begin(), indices.end());
    std::sort(I.begin(), I.end());

    VectorX<int8_t> perm(map.size());

    for (int8_t j = 0; j < indices.size(); ++j) {
        perm[j] = map[I[j]];
    }

    const auto& sd = wmtk::dart::SimplexDart::get_singleton(pt);
    int8_t inv = from_local_vertex_permutation(perm);
    return sd.inverse(inv);
}
int8_t from_vertex_permutation(PrimitiveType pt, Eigen::Ref<const VectorX<int64_t>> permutation)
{
    assert(pt == get_primitive_type_from_id(permutation.size() - 1));
    return from_vertex_permutation(permutation);
}
} // namespace wmtk::dart::utils
