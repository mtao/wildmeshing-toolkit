#include "from_local_vertex_permutation.hpp"
#include <algorithm>
#include <iterator>
#include <map>
#include <span>
#include <wmtk/autogen/edge_mesh/autogenerated_tables.hpp>
#include <wmtk/autogen/tet_mesh/autogenerated_tables.hpp>
#include <wmtk/autogen/tri_mesh/autogenerated_tables.hpp>
#include <wmtk/dart/SimplexDart.hpp>
namespace wmtk::dart::utils {
namespace {


template <size_t Rows, size_t Cols>
int8_t from_local_vertex_permutation_slow(
    Eigen::Ref<const VectorX<int8_t>> permutation,
    const int8_t p[Rows][Cols])
{
    using CMT = typename Vector<int8_t, Cols>::ConstMapType;
    for (size_t j = 0; j < Rows; ++j) {
        auto x = CMT(p[j]);
        if (x == permutation) {
            return j;
        }
    }
    return -1;
}

//defined(__GNUG__) && !
#if defined(__clang__) || !defined(WMTK_ENABLED_CXX20)
constexpr
#else
consteval
#endif
int64_t factorial(int8_t N)
{
    if (N <= 1) {
        return 1;
    } else {
        return N * factorial(N - 1);
    }
}

template <size_t Rows, size_t Cols>
std::array<std::pair<std::array<int8_t, Cols>, int8_t>, Rows> local_indexer(
    const int8_t p[Rows][Cols])
{
    std::array<std::pair<std::array<int8_t, Cols>, int8_t>, Rows> R;
    using CMT = typename Vector<int8_t, Cols>::ConstMapType;
    for (size_t j = 0; j < Rows; ++j) {
        auto x = CMT(p[j]);
        std::copy(x.begin(), x.end(), R[j].first.begin());
        R[j].second = j;
    }
    std::sort(R.begin(), R.end());
    return R;
}

template <size_t Rows, size_t Cols>
std::array<std::pair<std::array<int8_t, Cols>, int8_t>, Rows> local_indexer()
{
    if constexpr(Cols == 2) {
        return local_indexer<Rows,Cols>(autogen::edge_mesh::permutations);
    } else if constexpr(Cols == 3) {
        return local_indexer<Rows,Cols>(autogen::tri_mesh::permutations);
    } else if constexpr(Cols == 4) {
        return local_indexer<Rows,Cols>(autogen::tet_mesh::permutations);

    }

}

template <size_t Rows, size_t Cols>
int8_t get_index(
    const std::array<std::pair<std::array<int8_t, Cols>, int8_t>, Rows>& LI,
    std::array<int8_t, Cols> permutation)
{
    auto it = std::lower_bound(LI.begin(), LI.end(), permutation, [](const auto& a, const auto& b) {
        return std::lexicographical_compare(a.first.begin(), a.first.end(), b.begin(), b.end());
    });
    assert(std::equal(it->first.begin(), it->first.end(), permutation.begin(), permutation.end()));
    return it->second;
}

template <size_t Rows, size_t Cols>
int8_t get_index(
    const std::array<std::pair<std::array<int8_t, Cols>, int8_t>, Rows>& LI,
    Eigen::Ref<const Vector<int8_t, Cols>> permutation)
{
    auto it = std::lower_bound(LI.begin(), LI.end(), permutation, [](const auto& a, const auto& b) {
        return std::lexicographical_compare(a.first.begin(), a.first.end(), b.begin(), b.end());
    });
    assert(std::equal(it->first.begin(), it->first.end(), permutation.begin(), permutation.end()));
    return it->second;
}


template <size_t Rows>
int8_t from_local_vertex_permutation(Eigen::Ref<const Vector<int8_t, Rows>> permutation) {
    constexpr static int8_t F = factorial(Rows);
    const static auto LI = local_indexer<F, Rows>();
    return get_index<F, Rows>(LI, permutation);
}
} // namespace

int8_t from_local_vertex_permutation(Eigen::Ref<const VectorX<int8_t>> permutation)
{
    PrimitiveType pt = get_primitive_type_from_id(permutation.size() - 1);
    const static int8_t x = 1;
    switch (pt) {
    case PrimitiveType::Edge: return from_local_vertex_permutation<2>(permutation);
    case PrimitiveType::Triangle: return from_local_vertex_permutation<3>(permutation);
    case PrimitiveType::Tetrahedron: return from_local_vertex_permutation<4>(permutation);
    case PrimitiveType::Vertex: return 0;
    default: return -1;
    }
}
int8_t from_local_vertex_permutation(
    PrimitiveType pt,
    Eigen::Ref<const VectorX<int8_t>> permutation)
{
    assert(pt == get_primitive_type_from_id(permutation.size() - 1));
    return from_local_vertex_permutation(permutation);
}

int8_t from_vertex_permutation(Eigen::Ref<const VectorX<int64_t>> indices)
{
    std::map<int64_t, int8_t> map;
    // std::vector<int64_t> I(indices.size());
    for (int8_t j = 0; j < indices.size(); ++j) {
        map[indices(j)] = j;
    }
    std::vector<int64_t> I(indices.begin(), indices.end());
    // std::copy(indices.begin(), indices.end(),std::back_inserter(I));
    std::sort(I.begin(), I.end());

    VectorX<int8_t> perm(map.size());

    for (int8_t j = 0; j < indices.size(); ++j) {
        perm[j] = map.at(I[j]);
    }

    PrimitiveType pt = get_primitive_type_from_id(indices.size() - 1);
    const auto& sd = wmtk::dart::SimplexDart::get_singleton(pt);
    int8_t inv = from_local_vertex_permutation(perm);
    return sd.inverse(inv);
}
int8_t from_vertex_permutation(PrimitiveType pt, Eigen::Ref<const VectorX<int64_t>> permutation)
{
    assert(pt == get_primitive_type_from_id(permutation.size() - 1));
    return from_vertex_permutation(permutation);
}

template <size_t N>
int8_t from_local_vertex_permutation(const std::array<int8_t, N>& indices)
{
    const static auto LI = local_indexer<factorial(N), N>();

    static_assert(factorial(1) == 1);
    static_assert(factorial(2) == 2);
    static_assert(factorial(3) == 6);
    static_assert(factorial(4) == 24);
    return get_index<factorial(N), N>(LI, indices);
}

template <size_t N>
int8_t from_vertex_permutation(const std::array<int64_t, N>& indices)
{
    std::map<int64_t, int8_t> map;
    // std::vector<int64_t> I(indices.size());
    for (int8_t j = 0; j < indices.size(); ++j) {
        map[indices[j]] = j;
    }
    std::vector<int64_t> I(indices.begin(), indices.end());
    // std::copy(indices.begin(), indices.end(),std::back_inserter(I));
    std::sort(I.begin(), I.end());

    assert(map.size() == N);
    std::array<int8_t,N> perm;

    for (int8_t j = 0; j < indices.size(); ++j) {
        perm[j] = map.at(I[j]);
    }
    PrimitiveType pt = get_primitive_type_from_id(indices.size() - 1);
    const auto& sd = wmtk::dart::SimplexDart::get_singleton(pt);
    int8_t inv = from_local_vertex_permutation(perm);
    return sd.inverse(inv);

}




//template 
//int8_t from_local_vertex_permutation<1>(const std::array<int8_t, 1>& indices);
template 
int8_t from_local_vertex_permutation<2>(const std::array<int8_t, 2>& indices);
template 
int8_t from_local_vertex_permutation<3>(const std::array<int8_t, 3>& indices);
template 
int8_t from_local_vertex_permutation<4>(const std::array<int8_t, 4>& indices);

//template 
//int8_t from_vertex_permutation<1>(const std::array<int64_t, 1>& indices);
template 
int8_t from_vertex_permutation<2>(const std::array<int64_t, 2>& indices);
template 
int8_t from_vertex_permutation<3>(const std::array<int64_t, 3>& indices);
template 
int8_t from_vertex_permutation<4>(const std::array<int64_t, 4>& indices);
} // namespace wmtk::dart::utils
